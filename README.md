# git
## Ключевые моменты
- **<ins>git работает локально</ins>**<br>
- **<ins>само НЕ делается ничего - только по команде</ins>** так как точка фиксации - осмысленная сущность, важная для разработчика и она обязательно снабжается названием (комментарием)<br>
## git config
*- работа с файлом настройки .gitconfig*
> git config --global user.name "ваше имя или ник латиницей"<br>
> git config --global user.email ваша электронная почта
### cat ~/.gitconfig 
*- посмотреть настройки*
> git config --list <br>
## git init
*- сделать указанную (текущую) папку репозиторием*<br>
В зависимости от настроек Git может назвать начальную ветку или main, или master:
- сообщение, которое начинается со слов "Using 'master' as the name…" появится в том случае, если ветка по умолчанию будет называться master<br>

По итогу выполнения данной команды получим сообщение вида Initialized empty Git repository in <*ваша папка с проектом*>/.git/ (англ. «инициализирован пустой Git-репозиторий в <*ваша папка*>/.git/») - когда папка становится репозиторием - в ней создается подпапка .git. Git будет хранить в этой подпапке (.git) всю служебную информацию (историю изменений).<br>
### rm -rf .git
*- «разгитить» папку, если что-то пошло не так*<br>
Если удалить подпапку .git, то вся история проекта будет стёрта без возможности восстановления — останется только последняя версия файлов
## git status
*- проверить состояние репозитория*<br>
выведет:
- название текущей ветки: On branch master или On branch main;
- сообщение о том, что в репозитории ещё нет коммитов: No commits yet (после того как мы сделаем первый коммит, команда git status перестанет выводить сообщение No commits yet);
- сообщение, которое говорит: «чтобы что-нибудь закоммитить (то есть зафиксировать), нужно сначала это создать» — nothing to commit (create/copy files and use "git add" to track)

возможны следующие статусы файлов в репозитории:
- untracked - неотслеживаемый;
- staged - добавленный в индекс, индексируемый (англ.: «выдвинутый на плацдарм»);
- modified изменённый;
- committed - боевой, на жаргоне разработчиков «коммит» или «закоммиченный» (англ.: «брошенный в бой»).<br>

логика работы git:
1. как только в инициализированной папке появляется файл, он попадает в состояние неотслеживаемый. Что бы вы ни делали с этим файлом, Git будет игнорировать изменения.
2. Чтобы Git обратил внимание на этот файл и стал учитывать вносимые в него изменения, файл нужно добавить в индекс. После этого файл перейдёт в состояние «добавленный», а если после этого внести в него изменения — в состояние «изменённый».
3. Когда мы закончим изменение файла, нам нужно его «сохранить» — сообщить программе Git, что актуальное состояние файла нужно запомнить. Позже это позволит нам вернуться к этой версии, если что-то пойдёт не так. Такое сохранение называют коммитом

## git add
*- команда для добавления файлов в индекс Staging Area (англ. «плацдарм», «место временного сосредоточения», «временное хранилище»)*

подготовит файлы к сохранению - запоминает текущее содержимое (контент) файла, !_но НЕ СОХРАНЯЕТ содержимое файлов в репозитории
> git add --all<br>
или<br>
> git add . # добавит текущую директорию (все файлы и папки), файлы из вложенных каталогов так же добавятся в индекс

> git add file_name # добавит конкретный файл
## git commit -m "text_commit's"
*- выполнить коммит (от англ. commit — «совершать», «фиксировать»), сохранение, или фиксацию состояния файлов*<br>
Чтобы сохранить состояние (текущую версию) файлов нужно сделать коммит — зафиксировать все сделанные изменения в «боевой версии» и оставить комментарий.
- ключ -m (от англ. message — «сообщение»), который присваивает коммиту сообщение (само сообщение пишется после ключа -m в кавычках), сообщение лучше писать латинским алфавитом, чтобы они корректно отображались в командной строке.

по итогам отработки команды выведет информацию о коммите
- [master (root-commit) baa3b6e] значит коммит был в ветке master;
	- root-commit — это самый первый, или «корневой» (англ. root), коммит в ветке, у следующих коммитов такой надписи не будет;
	- baa3b6e — сокращённый идентификатор коммита
- 2 files changed, 1 insertion(+) значит:
	- изменились два файла (readme.txt и todo.txt);
	- одна строка была добавлена
- Строки вида create mode 100644 readme.txt — это более подробная информация о новых (добавленных в Git) файлах:
	- create (англ. «создать») говорит, что файл был создан. Если бы файл был удалён, на этом месте было бы слово delete (англ. «удалить»).
	- mode 100644 сообщает, что это обычный файл. Также возможны варианты 100755 для исполняемых файлов (например, что-нибудь.exe) и 120000 для файлов-ссылок в Linux. Файлы-ссылки не содержат данных сами по себе, а только ссылаются на другие файлы — как «ярлыки» в Windows.

Сначала команда git add сообщает Git, какие именно файлы нужно сохранить и какую их версию. Затем с помощью команды git commit происходит само сохранение

Если провести аналогию, команду git add можно сравнить с добавлением товаров в корзину в интернет-магазине, а коммит — с оформлением и оплатой заказа<br>
Или сначала вы просите друзей встать в ряд — это команда git add. И только после того, как все заняли свои места, поправили волосы и улыбнулись, вы нажимаете кнопку и делаете снимок — это команда git commit. Сам получившийся снимок и будет коммитом. На этой фотографии с обратной стороны ещё есть подпись (комментарий).
## git log
*- просмотреть историю коммитов*
## ssh ключи
### проверка наличия ssh ключей
> cd ~<br>
> ls -la .ssh/ # вывели список созданных ключей<br>
или<br>
> ls -a ~/.ssh
### генерация SSH-ключа
> ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"

Если вы видите сообщение об ошибке, то, скорее всего, ваша система не поддерживает алгоритм шифрования ed25519

тогда
> ssh-keygen -t rsa -b 4096 -C "электронная почта, к которой привязан ваш аккаунт на GitHub" 

после ввода:

- Generating public/private rsa key pair. # сгенерированы публичный и приватный ключи 
- укажите место хранения ключей:
	- Enter a file in which to save the key (C:\Users\<имя_пользователя>\.ssh\):[Press enter] 
- программа запросит кодовую фразу (англ. passphrase) для доступа к SSH-ключу, можно оставить поле пустым
	
### проверить правильность ключа на github (после прописывания ключа в своем профиле на github)
> ssh -T git@github.com 

если подключение в первый раз - проверить ключи GitHub:
(https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints)
## git remote add
*- привязать удалённый репозиторий к локальному*
> cd ~/dev/first-project
> git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git 

два параметра: имя удалённого репозитория и его URL. В качестве имени используйте слово origin

origin (англ. «источник») — стандартный псевдоним, с помощью которого можно обращаться к главному удалённому репозиторию (обычно такой репозиторий один)
### git remote -v
*Убедиться, что репозитории связаны*
- флаг -v — короткая форма флага --verbose (англ. «подробный»). Он позволяет показать больше информации в выводе.
## git clone
*- первоначально скопировать репозиторий из облака на локальное хранилище*
> git clone [адрес, откуда копируем] [путь до папки, куда копируем]
- если мы находимся в той папке, куда нужно клонировать, путь указывать не надо. Достаточно указать ссылку на клонируемый проект
> git clone https://github.com/<user>/<repository>.git
## git push
*- отправить изменения на удалённый репозиторий*

В первый раз эту команду нужно вызвать с флагом -u и параметрами origin (имя удалённого репозитория) и main или master (название текущей ветки)
> git push -u origin main # Если команда приведёт к ошибке, попробуйте заменить main на master

Флаг -u свяжет локальную ветку с одноимённой удалённой (на подобие тому, как связываем локальный и удалённый репозитории)

В дальнейшем можно писать просто git push
## git fetch
*- просмотреть (загрузить) список коммитов, которых нет у меня локально, выбрать только нужные (например по определенным файлам проекта)*
## git pull
*- заносит все созданные коммиты в вашу рабочую (локальную) ветку (репозиторий)*
Если вы храните свои репозитории на разных компьютерах, то когда вы публикуете сделанные на одном компьютере изменения, на другом — их нужно получить командой git pull.

Выполнение этой команды может привести к конфликтам, так как все изменения при получении сразу сливаются с вашей веткой - поэтому, если ведется параллельная работа над проектом - каждому ветку, потом их сливать в единое целое.
## .gitignore
*- текстовый документ, в каждой строчке которого написана маска файлов, которые не должны попасть на удалённый репозиторий после команды git push*
### примеры шаблонов в строках файла .gitignore
```cfg
# комментарий — эта строка игнорируется
# игнорировать файлы с расширением .pyc,
# * - любое количество символов (ноль и больше),
*.pyc
# НО отслеживать файл main.pyc
# несмотря на то, что мы игнорируем все .pyc файлы с помощью предыдущего правила
!main.pyc
# ? - ноль или один символ
# Исключить файлы text.txt, test.txt, tet.txt и т.д.
te?t.txt
# игнорировать только файл main.py находящийся в корневом каталоге
# не относится к файлам вида <папка>/main.py
/main.py
# игнорировать все файлы в каталоге .idea/
.idea/
# игнорировать файлы с расширением .txt, только в папке doc, но не в подпапках папки doc
doc/*.txt
# игнорировать все .txt файлы в каталоге doc/ и всех его подкаталогах
doc/**/*.txt
```
### Чтобы удалить файл 
Если вы добавили файл в репозиторий и опубликовали изменения командой git push, но не добавили шаблон для файла в .gitignore, то он будет опубликован на github. После добавления шаблона в .gitignore, изменения в файле не будут отражаться на github, но сам файл не удалится с репозитория.<br>
Чтобы удалить файл удалите его, зафиксируйте и опубликуйте изменения. Затем добавьте файл и добавьте его шаблон в .gitignore. После этого снова опубликуйте изменения.
## README.md
[пример](https://github.com/git/git/blob/master/README.md)
Как правило, в README.md проекта можно найти следующую информацию
- название проекта и его краткое описание: кем создан, для чего, какие решает задачи и какие закрывает проблемы;
- технологии, которые применяются в проекте, в чём его отличие от аналогичных;
- документация проекта — подробная инструкция о том, что представляет собой проект;
- планы проекта, если они есть.
## Markdown. Базовый синтаксис.
### Заголовки, абзацы и перенос
- Заголовки разных уровней создают решётками:
```
# H1 — заголовок первого уровня, самый большой
## H2 — заголовок второго уровня, поменьше
### H3
#### H4
##### H5
###### H6 — заголовок шестого уровня, самый маленький
```
- Чтобы добавить черту под заголовком или абзацем:
```
#### Заголовок 4
---
Текст над чертой
---
Текст под чертой 
```
- Чтобы сделать разрыв строки, нужно поставить два пробела (в примере ниже они обозначены точками ⋅⋅) или сочетание символов:<br>
```
Текст до переноса⋅⋅  
Текст после переноса <br>
Текст после второго переноса
```
-  Чтобы начать новый параграф, в конце предыдущей строки должно стоять два символа переноса. Для этого нужно нажать Enter два раза.<br>
Если сделать один перенос строки и не поставить два пробела, текст сольётся в одну строку.
### Выделение текста
- Чтобы выделить текст курсивом (*текст*), его заключают в звёздочки (астериски) или нижние подчёркивания:
```
Курсив — это *звёздочки* или _подчёркивания_.
```
- Чтобы выделить текст полужирным шрифтом (**текст**), его окружают двойными звёздочками или двойными нижними подчёркиваниями:
```
Полужирный шрифт — двойные **звёздочки** или двойные __подчёркивания__.
```
- Можно совмещать:
```
например совместить выделение **звёздочки и _подчёркивания_**.
```
- Чтобы подчеркнуть текст (<ins>текст</ins>), его окружают тегами ins:<br>
```
<ins>Подчеркнутый текст</ins>
```
- Чтобы зачеркнуть текст (~~текст~~), его окружают двойными волнистыми линиями — тильдами
```
~~Зачёркнутый текст.~~
```
### Списки
#### Нумерованный список
Для оформления нумерованного списка достаточно поставить в начало строки цифры с точкой:
```
1. Первый пункт нумерованного списка.
2. Второй пункт.
	1. Вложенные элементы описываются так
```
#### Ненумерованный список
Ненумерованный список создаётся звёздочкой с пробелом в начале строки либо дефисом с пробелом:
```
* первый пункт ненумерованного списка;
* второй пункт ненумерованного списка

- первый пункт ненумерованного списка;
- второй пункт ненумерованного списка
	- вложенный элемент маркированного списка
```
### Ссылки
Чтобы сделать ссылкой часть текста, его заключают в квадратные скобки, а затем указывают нужный адрес в круглых скобках:<br>
```
[Яндекс](https://www.yandex.ru)
```
Также можно добавить ссылке тайтл (от англ title — «название», «заголовок»). Тайтл — это всплывающая подсказка, которая появляется при наведении мыши на ссылку. Тайтл нужно заключить в кавычки и указать внутри скобок после адреса
```
[Яндекс](https://www.yandex.ru "Я Yandex!")
```
### Код
Чтобы оформить текст как код, нужно окружить его тройками косых кавычек — грависов. После первой тройки грависов указывают язык программирования, на котором написан код. В маркдауне есть поддержка синтаксиса почти всех популярных языков и инструментов.
```
```bash
ls - la
```                      													.
```
```
```html
<h1>А я просто текст</h1>
```																.
```

внимание: вторая тройка тройных кавычек стоит на отдельной строке
### Цитаты
```
> Именно так оформляются цитаты
```
### Таблицы:
```
| Markdown 		| Поддерживает 		 | Таблицы 		       |
| :-------------------- | ---------------------: |:---------------------------:|
| с выравниванием слева | с выравниванием справа | и с выравниванием по центру |
```
### Руководства по маркдауну
- [руководство по маркдауну](https://gist.github.com/fomvasss/8dd8cd7f88c67a4e3727f9d39224a84c)
- [еще руководство по маркдауну](https://www.markdownguide.org/cheat-sheet/)
- [и еще руководство по маркдауну](https://daringfireball.net/projects/markdown/)
<br>

- [интерактивный тур по git](https://githowto.com/ru)
